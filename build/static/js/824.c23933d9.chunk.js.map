{"version":3,"file":"static/js/824.c23933d9.chunk.js","mappings":"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","sources":["components/appBanner/AppBanner.js","components/errorMessage/ErrorMessage.js","components/pages/UniSinglePage.js","hooks/http.hook.js","keys/apiKey.js","services/MarvelService.js","components/skeleton/Skeleton.js","utils/setContent.js"],"sourcesContent":["import './appBanner.scss';\nimport avengers from '../../resources/img/Avengers.png';\nimport avengersLogo from '../../resources/img/Avengers_logo.png';\n\nconst AppBanner = () => {\n    return (\n        <div className=\"app__banner\">\n            <img src={avengers} alt=\"Avengers\"/>\n            <div className=\"app__banner-text\">\n                New comics every week!<br/>\n                Stay tuned!\n            </div>\n            <img src={avengersLogo} alt=\"Avengers logo\"/>\n        </div>\n    )\n}\n\nexport default AppBanner;","import img from './error.gif';\r\n\r\nconst ErrorMessage = () => {\r\n    return (\r\n        <img src={img} alt=\"error\" style={{display: 'block', width: '250px', height: '250px', objectFit: 'contain', margin: '0 auto'}}/>\r\n    )\r\n}\r\n\r\nexport default ErrorMessage;","import { useParams } from 'react-router-dom';\r\nimport { useEffect, useState } from 'react';\r\n\r\nimport AppBanner from \"../appBanner/AppBanner\";\r\nimport useMarvelService from '../../services/MarvelService';\r\nimport setContent from '../../utils/setContent';\r\n\r\n// Хотелось бы вынести функцию по загрузке данных как отдельный аргумент (getComics + getCharacter)\r\n// Но тогда мы потеряем связь со стэйтами загрузки и ошибки\r\n// А если вынесем их все в App.js - то они будут одни на все страницы!!!\r\n\r\nconst UniSinglePage = ({Component, dataType}) => {\r\n    const {itemId} = useParams();\r\n    const [data, setData] = useState(null);\r\n\r\n    const {getCharacter, getComics, clearError, process, setProcess} = useMarvelService();\r\n\r\n    useEffect(() => {\r\n        updateItem();\r\n    }, [itemId]);\r\n\r\n    const updateItem = () => {\r\n        clearError();\r\n        if (dataType === 'char') {\r\n            getCharacter(itemId)\r\n                .then(onItemLoaded)\r\n                .then(() => setProcess('confirmed'));\r\n        } else if (dataType === 'comic') {\r\n            getComics(itemId)\r\n                .then(onItemLoaded)\r\n                .then(() => setProcess('confirmed'));\r\n        }\r\n    }\r\n\r\n    const onItemLoaded = (data) => {\r\n        setData(data);\r\n    }\r\n\r\n    // const errorMessage = error ?  <ErrorMessage/> : null;\r\n    // const spinner = loading ? <Spinner/> : null;\r\n    // const content = !(loading || error || !item) ? <Component item={item}/> : null;\r\n\r\n    return (\r\n        <>\r\n            <AppBanner/>\r\n            {setContent(process, Component, data)}\r\n        </>    \r\n    )\r\n}\r\n\r\nexport default UniSinglePage;","import {useState, useCallback} from \"react\";\r\n\r\nexport const useHttp = () => { // http - > так часто называют сущности которуе будут работать с запросами\r\n    // const [loading, setLoading] = useState(false);\r\n    // const [error, setError] = useState(null);\r\n    const [process, setProcess] = useState('waiting'); // process - какой процесс будет внутри компонента. waiting - ожидание какого-то действия. обозначили текущее состояние\r\n\r\n    // тут будут хуки которые обрабатывают загрузку сервера и ошибки сервера, поэтому логично обращение к серверу тоже вынести сюда\r\n    const request = useCallback(async (url, method = 'GET', body = null, headers = {'Content-Type': 'application/json'}) => { // body null необходимо при get-запросах\r\n        //setLoading(true);\r\n        setProcess('loading'); // загружаем данные с сервера\r\n\r\n        // этот метод будет только отправлять запрос на сервер, но не будет его обрабатывать. Поэтому для обработки ошибок будет следующая конструкция\r\n        try {\r\n            const response = await fetch(url, {method, body, headers}); // await ждет ответ от сервера. В response получаем promise \r\n            if (!response.ok) {\r\n                throw new Error(`Could not fetch ${url}, status: ${response.status}`);\r\n            }\r\n\r\n            const data = await response.json(); // опять ждем когда сконвертируется\r\n\r\n            // если данные загрузились(код дошел до этого участка)\r\n            //setLoading(false);\r\n            // setProcess('confirmed'); // запрос произведен - будем менять этот стейт в самой функции, т.к. иначе из-за асинхронности и еще не обработанности данных будет ошибка\r\n\r\n            return data; // данные не трансформированные - чистые\r\n        } catch(e) {\r\n            //setLoading(false);\r\n            //setError(e.message); // true\r\n            setProcess('error');\r\n            throw e;\r\n        }\r\n\r\n    }, []);\r\n\r\n    const clearError = useCallback(() => {\r\n        //setError(null);\r\n        setProcess('loading');\r\n    }, []);\r\n\r\n    return {//loading, \r\n            //error, \r\n            request, \r\n            clearError, \r\n            process, \r\n            setProcess};\r\n}","export const _apiKey = 'apikey=272103bc80d57e1c4159f0364fe95129';","import { useHttp } from \"../hooks/http.hook\";\r\nimport { _apiKey } from \"../keys/apiKey\";\r\n\r\nconst useMarvelService = () => { // это тоже кастомный хук для использования сервиса\r\n    const {//loading, \r\n            request, \r\n            //error, \r\n            clearError, \r\n            process, \r\n            setProcess} = useHttp();\r\n\r\n    const _apiBase = 'https://gateway.marvel.com:443/v1/public/';\r\n    const _baseOffset = 210; // базовый отступ для персонажей(чтобы не с самого первого персонажа(типо там не оч интересные для демонстрации))\r\n    const _baseOffsetComics = 0;\r\n\r\n    const getAllCharacters = async (offset = _baseOffset) => { // значение для offset по-умолчанию, если туда ничего не передается\r\n        const res = await request(`${_apiBase}characters?limit=9&offset=${offset}&${_apiKey}`); // getResource -> request - то же самое, только тут мы еще работаем с состоянием\r\n        return res.data.results.map(_transformCharacter); // передаем callback-функцию\r\n    }\r\n\r\n    const getAllComics = async (offset = _baseOffsetComics) => {\r\n        const res = await request(`${_apiBase}comics?orderBy=issueNumber&limit=8&offset=${offset}&${_apiKey}`);\r\n        return res.data.results.map(_transformComic);\r\n    }\r\n\r\n    const getComics = async (id) => {\r\n        const res = await request(`${_apiBase}comics/${id}?${_apiKey}`);\r\n\t\treturn _transformComic(res.data.results[0]);\r\n    }\r\n\r\n    const getCharacter = async (id) => {\r\n        const res = await request(`${_apiBase}characters/${id}?${_apiKey}`);\r\n\r\n        return _transformCharacter(res.data.results[0]);\r\n    }\r\n    \r\n    // Вариант модификации готового метода для поиска по имени.\r\n\t// Вызывать его можно вот так: getAllCharacters(null, name)\r\n\r\n\t// const getAllCharacters = async (offset = _baseOffset, name = '') => {\r\n\t//     const res = await request(`${_apiBase}characters?limit=9&offset=${offset}${name ? `&name=${name}` : '' }&${_apiKey}`);\r\n\t//     return res.data.results.map(_transformCharacter);\r\n\t// }\r\n\r\n\t// Или можно создать отдельный метод для поиска по имени\r\n\r\n    const getCharacterByName = async (name) => {\r\n        const res = await request(`${_apiBase}characters?name=${name}&${_apiKey}`);\r\n        // в результате может быть несколько, возьмем значение иначе\r\n        // return _transformCharacter(res.data.results[0]);\r\n        return res.data.results.map(_transformCharacter);\r\n    }\r\n\r\n    const _transformCharacter = (char) => {\r\n        let descr = char.description.length === 0 ? 'Doesn`t have any description yet' : char.description;\r\n        if (descr.length > 210) {\r\n            descr = descr.slice(0, 210) + '...';\r\n        }\r\n        return {\r\n            id: char.id,\r\n            name: char.name,\r\n            description: descr, //char.description,\r\n            fulldescription: char.description.length === 0 ? 'Doesn`t have any description yet' : char.description,\r\n            thumbnail: char.thumbnail.path + '.' + char.thumbnail.extension,\r\n            homepage: char.url,\r\n            wiki: char.urls[1].url,\r\n            comics: char.comics.items\r\n        }\r\n    }\r\n\r\n    const _transformComic = (comic) => {\r\n        return {\r\n            id: comic.id,\r\n            name: comic.title,\r\n            description: comic.description || \"There is no description\",\r\n            pageCount: comic.pageCount\r\n\t\t\t\t? `${comic.pageCount} p.`\r\n\t\t\t\t: \"No information about the number of pages\",\r\n            language: comic.textObjects[0]?.language || \"en-us\",\r\n            price: comic.prices[0].price ? `${comic.prices[0].price}$` : \"not available\",\r\n            thumbnail: comic.thumbnail.path + '.' + comic.thumbnail.extension\r\n        }\r\n    }\r\n\r\n    return {//loading, \r\n            //error, \r\n            process, \r\n            setProcess,\r\n            getAllCharacters, \r\n            getCharacter, \r\n            clearError,\r\n            getAllComics, \r\n            getComics, \r\n            getCharacterByName}\r\n}\r\n\r\nexport default useMarvelService;","import './skeleton.scss';\n\nconst Skeleton = () => {\n    return (\n        <>\n            <p className=\"char__select\">Please select a character to see information</p>\n            <div className=\"skeleton\">\n                <div className=\"pulse skeleton__header\">\n                    <div className=\"pulse skeleton__circle\"></div>\n                    <div className=\"pulse skeleton__mini\"></div>\n                </div>\n                <div className=\"pulse skeleton__block\"></div>\n                <div className=\"pulse skeleton__block\"></div>\n                <div className=\"pulse skeleton__block\"></div>\n            </div>\n        </>\n    )\n}\n\nexport default Skeleton;","import Spinner from '../components/spinner/Spinner';\r\nimport ErrorMessage from '../components/errorMessage/ErrorMessage';\r\nimport Skeleton from '../components/skeleton/Skeleton';\r\n\r\nconst setContent = (process, Component, data) => { // передаем процесс нужный и данные по персонажу(если нужно)\r\n    // отталкиваемся от процесса и в зависимости от него генерируем разные кусочки интерфейса\r\n    switch (process) {\r\n        case 'waiting':\r\n            return <Skeleton/>;\r\n            break;\r\n        case 'loading':\r\n            return <Spinner/>;\r\n            break;\r\n        case 'confirmed':\r\n            return <Component data={data}/>; // тут реакт будет пытаться отрендерить компонент с данными, которых еще не существует, они не были обработаны. Т.к. Сначала мы устанавливаем процесс confirmed, и потом передаем данные для обработки в marvelServices(из http.hook.js)\r\n            // решение -> передать функцию по ручному изменению состояния в сам компонент\r\n            break;\r\n        case 'error':\r\n            return <ErrorMessage/>;\r\n            break;\r\n        default: \r\n            throw new Error('Unexpected process state');\r\n    }\r\n}\r\n\r\nexport default setContent;"],"names":["AppBanner","_jsxs","className","children","_jsx","src","avengers","alt","avengersLogo","ErrorMessage","img","style","display","width","height","objectFit","margin","_ref","Component","dataType","itemId","useParams","data","setData","useState","getCharacter","getComics","clearError","process","setProcess","useMarvelService","useEffect","updateItem","then","onItemLoaded","_Fragment","setContent","_apiKey","request","useHttp","useCallback","async","url","method","arguments","length","undefined","body","headers","response","fetch","ok","Error","concat","status","json","e","_apiBase","_transformCharacter","char","descr","description","slice","id","name","fulldescription","thumbnail","path","extension","homepage","wiki","urls","comics","items","_transformComic","comic","_comic$textObjects$","title","pageCount","language","textObjects","price","prices","getAllCharacters","offset","results","map","res","getAllComics","getCharacterByName","Skeleton","Spinner"],"sourceRoot":""}